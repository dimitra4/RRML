{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"RESTful Resource Mapping Language (RRML)","text":"<p>The RESTful Resource Mapping Language (RRML) is a lightweight, declarative language for defining RESTful API resources and their mappings to relational databases.  </p> <p>Instead of writing boilerplate code for every new endpoint, developers and domain experts can describe resources in human-readable YAML files, including:</p> <ul> <li>Resource attributes and identifiers  </li> <li>Database mappings and joins  </li> <li>Query logic, functions, and aggregations  </li> <li>Validation constraints  </li> </ul> <p>These language is automatically validated and transformed into executable code through a template-based code generation pipeline. The result is a set of fully functional API components \u2014resources, repositories, mappers, and query builders\u2014 aligned with the existing backend.</p>"},{"location":"#why-use-rrms","title":"Why use RRMS","text":"<ul> <li>Reduce boilerplate: eliminate repetitive coding of endpoints.  </li> <li>Consistency by design: endpoints follow the same structure and rules.  </li> <li>Expressiveness: model simple to complex query logic in a declarative way.  </li> <li>Faster onboarding: new developers or domain experts can contribute without mastering backend frameworks.  </li> <li>Flexibility: templates can target different runtimes (Java today, Python/FastAPI or others tomorrow).  </li> </ul>"},{"location":"#who-is-this-for","title":"Who is this for","text":"<ul> <li>API developers who want to speed up endpoint creation.  </li> <li>Domain experts who can describe data models without writing code.  </li> <li>Teams aiming for maintainability, scalability, and alignment across APIs.  </li> </ul>"},{"location":"#how-it-works","title":"How it works","text":"<ol> <li>Write YAML files describing resources and their mappings. Check out some YAML examples </li> <li>Validate them against the RRMS metamodel (Pydantic). They must conform to the main Pydantic object models  </li> <li>Generate backend code automatically via Jinja templates.  </li> <li>Deploy the generated classes as working REST endpoints.                </li> </ol>"},{"location":"#main-pydantic-object-models","title":"Main Pydantic Object Models","text":"<p>Each YAML file need to conform to the below main Pydantic Object Models, that form the actual basis of the Specification.</p> <ul> <li>Resource: Represents the canonical definition of a domain resource exposed through an API</li> <li>ResourceToDbMapper: Describes how a resource is backed by database entities, how query logic is applied and how data are transformed</li> </ul>"},{"location":"AdditionalTable/","title":"AdditionalTable","text":""},{"location":"AdditionalTable/#additionaltable","title":"AdditionalTable","text":"<p>Represents an additional table that can be joined with the master table or another additional table in order to enrich the resource definition.</p> <p>Joins can be defined as <code>innerJoin</code>, <code>leftJoin</code>, <code>rightJoin</code>, or as a <code>subselect</code>.</p> <p>Example YAML</p> <pre><code>additionalTables:\n  - namedb: \"eras\"\n    dbSchema: \"cms_oms\"\n    relation: \"leftJoin\"\n    relationTable: *masterTable\n    relationKeys:\n      - tableKey: \"era_id\"          # Same name in both tables\n        # - tablekey: \"status\"      # Different names\n        #   targetKey: \"era_status\"\n    fields: \n      - attNamedb: \"name\"\n        attNameResource: \"era\"\"\n</code></pre> <p>corresponds to: <pre><code>SELECT eras.name as era\nFROM cms_oms.fills fills\nLEFT JOIN cms_oms.eras eras\n  ON fills.era_id = eras.era_id\n</code></pre></p> <p>Attributes:</p> Name Type Status Description Examples <code>namedb</code> str Required The name of the database's additional table <code>dbSchema</code> str Required The schema of the database's addtional table <code>relation</code> Literal[innerJoin, leftJoin, asSubselect, rightJoin] Required The relation between the master table and the additional table. Options:- <code>innerJoin</code>: Only include matching records from both tables- <code>leftJoin</code>: Include all records from master, and matched from related- <code>rightJoin</code>: Include all records from related, and matched from master- <code>asSubselect</code>: Join via a subquery instead of directly <code>relationTable</code> str Required The name of the table to which the additional table is related. This must match either a previously defined <code>namedb</code> in <code>additionalTables</code> or the <code>masterTable</code> <code>relationKeys</code> List[RelationKey] Required The names of the relation keys (columns) of the tables related <code>conditions</code> List[Condition, Regex] Optional A list of conditions to apply as filters <code>fields</code> List[TableAttribute] Optional List of the mapping between the attributes of the resource and the fields in the database"},{"location":"Attribute/","title":"Attribute","text":""},{"location":"Attribute/#attribute","title":"Attribute","text":"<p>The Attribute defines a single field of a Resource. Each attribute has a name and type, may be marked as the key identifier of the resource, and can optionally include additional metadata for documentation and query behavior.</p> <p>Attributes:</p> Name Type Status Description Examples <code>name</code> str Required Name of the attribute of the resource id, start_time, run_number <code>type</code> str Required The data type of the attribute of the resource according to the standardized mapping_types YAML file <code>isKey</code> bool Optional Explicitly determine true if the attribute is the actual identifier of the resource <code>meta</code> MetaData Optional The meta data of the attribute"},{"location":"CaseExpression/","title":"CaseExpression","text":""},{"location":"CaseExpression/#caseexpression","title":"CaseExpression","text":"<p>Represents a CASE expression in SQL. A <code>CaseExpression</code> evaluates a condition and returns a value via the <code>then</code> clause. If no <code>when</code> branch matches, the optional <code>else</code> provides a fallback value.</p> <p>Example YAML</p> <pre><code>case_expression: \n  - when: { column: \"start_time\", operator: \"isnot\", value: \"null\"}\n    then: 1\n</code></pre> <p>corresponds to: <pre><code>CASE\n  WHEN start_time IS NOT NULL THEN 1\nEND\n</code></pre></p> <p>Attributes:</p> Name Type Status Description Examples <code>when</code> Condition Required A condition that must be met for this branch to apply. Must contain <code>column</code>, <code>operator</code>, and/or <code>value</code> {'column': 'stablebeam', 'operator': 'eq', 'value': 1} <code>else_</code> str Required Fallback value if no conditions match <code>then</code> str Required The resulting value if this condition matches"},{"location":"Condition/","title":"Condition","text":""},{"location":"Condition/#condition","title":"Condition","text":"<p>Represents a WHERE condition applied in a query. A <code>Condition</code> defines a table, column, operator, and comparison value. Operators may be arithmetic or comparison operators. Multiple conditions can also be combined in a list.</p> <p>Example YAML</p> <pre><code>conditions:\n  - column: \"stable_beams\"  \n    operator: \"eq\"\n    value: 1                   \n  - column: \"enabled\" \n    operator: \"eq\"\n    value: 1      \n</code></pre> <p>Attributes:</p> Name Type Status Description Examples <code>table</code> str Optional The table name of the referenced column <code>column</code> str Required The name of the database column that the condition applies to run_number, name, status <code>operator</code> ArithmeticOperator, ComparisonOperator Required The comparison or arithmetic operator to use in the condition eq <code>value</code> str, int, float, bool, List[str, int, float, bool] Required The value to compare the column against. It can be a string, number, boolean, or a list of such values (used with the <code>in</code> operator). string_value, 42, True, [1, 2, 3]"},{"location":"DBColumnReference/","title":"DBColumnReference","text":""},{"location":"DBColumnReference/#dbcolumnreference","title":"DBColumnReference","text":"<p>References a database column by its table and column name. Used throughout the specification to unambiguously refer to database fields in conditions, expressions, or mappings.</p> <p>Example YAML</p> <pre><code>table: \"eras\"\ncolumn: \"name\"\n</code></pre> <p>corresponds to: <pre><code>eras.name\n</code></pre></p> <p>Attributes:</p> Name Type Status Description Examples <code>table</code> str Required The table name of the referenced column <code>column</code> str Required The name of the column being referenced."},{"location":"Examples/","title":"YAML Examples","text":"<p>This page provides practical YAML examples that demonstrate how to define resources, mappings, and query behavior using the RRMS specification. Each scenario illustrates a common use case, starting with simple one-to-one mappings and gradually introducing more complex structures with additional tables, joins, and expressions.</p>"},{"location":"Examples/#simple-case-scenarios","title":"Simple Case Scenarios","text":""},{"location":"Examples/#mapping-with-a-single-database-table","title":"Mapping with a single database table","text":"<p>The master table is <code>EVENT</code>, with no <code>additionalTables</code>. The resource represents the retrieval of events from the Data Acquisition system. </p> <p>Resource YAML</p> <pre><code>resource:\n  resource_name: \"daqevent\"\n  version: \"1.0.0\"\n  hasMeta: \"true\"\n  fields:\n    - name: \"eventid\"\n      type: \"long\"\n      isKey: true\n      meta:\n        title: \"Event id\"\n        description: \"The id of the event\"\n        searchable: true\n        sortable: true\n    - name: \"datetime_field\"\n      type: \"datetime\"\n      meta:\n        title: \"Event datetime\"\n        description: \"The datetime that the event occured\"\n        searchable: true\n        sortable: true\n    - name: \"display\"\n      type: \"boolean\"\n      meta:\n        title: \"display\"\n        description: \"Event display\"\n        searchable: true\n        sortable: true  \n    - name: \"message\"\n      type: \"string\"\n      meta:\n        title: \"Event message\"\n        description: \"The message of the event with all details\"\n        searchable: true\n        sortable: true\n    - name: \"status\"\n      type: \"integer\"\n      meta:\n        title: \"Event status\"\n        description: \"The status of the event\"\n        searchable: true\n        sortable: true       \n</code></pre> <p>ResourceToDbMapper YAML</p> <pre><code>resourceToDbMapper:\n  resource_name: \"daqevent\"\n  masterTable: \"event\"\n  dbSchema: \"daq_expert\"\n  fields:\n    - attNamedb: \"ID\"\n      attNameResource: \"eventid\"\n    - attNamedb: \"INSERT_DATETIME\"\n      attNameResource: \"datetime_field\"\n    - attNamedb: \"DISPLAY\"\n      attNameResource: \"display\"\n    - attNamedb: \"MESSAGE\"\n      attNameResource: \"message\"\n    - attNamedb: \"EVENT_STATUS\"\n      attNameResource: \"status\"\n  defaultSort:\n    fields:\n      - \"eventid\"\n    order: \"asc\"\n    nulls: \"last\"\n  pagination: \"enabled\"\n  rowCounting: \"enabled\"\n</code></pre>"},{"location":"Examples/#mapping-with-two-database-tables","title":"Mapping with two database tables","text":"<p>The master table is <code>ERAS</code> and <code>additionalTables</code> <code>RUNS</code>. The resource retrieves eras along with their first and last run numbers and corresponding times. </p> <p>Resource YAML</p> <pre><code>---\nresource:\n  resource_name: \"era\"\n  version: \"1.0.0\"\n  hasMeta: true # include meta \n  fields:\n    - name: \"name\"\n      type: \"string\"\n      isKey: true # identifier of the resource\n      meta:\n        description: \"Era name\"\n        searchable: true\n        sortable: true\n    - name: \"start_time\"\n      type: \"datetime\"\n      meta:\n        title: \"Start time first run\"\n        description: \"Time when the first run of this era period was started\"\n        searchable: true\n        sortable: true\n    - name: \"end_time\"\n      type: \"datetime\"\n      meta:\n        title: \"Stop time last run\"\n        description: \"Time when the last run of this era period was stopped\"\n        searchable: true\n        sortable: true\n    - name: \"start_run\"\n      type: \"integer\"\n      meta:\n        title: \"First run\"\n        description: \"First run number of this era period\"\n        searchable: true\n        sortable: true\n    - name: \"end_run\"\n      type: \"integer\"\n      meta:\n        title: \"Last run\"\n        description: \"Last run number of this era period\"\n        searchable: true\n        sortable: true\n</code></pre> <p>ResourceToDbMapper YAML</p> <pre><code>masterTable: &amp;masterTable \"eras\"\n\nresourceToDbMapper:\n  resource_name: \"era\"\n  masterTable: \"eras\"\n  dbSchema: \"oms\"\n  fields: \n    - attNamedb: \"name\"\n      attNameResource: \"name\"\n  additionalTables:\n    - namedb: \"runs\"\n      dbSchema: \"oms\"\n      relation: \"asSubselect\"\n      relationTable: *masterTable\n      relationKeys: \n        - tableKey: \"era_id\" \n      fields: \n        - attNamedb: \"run_number\"\n          function: \n            name: \"max\"\n          attNameResource: \"end_run\"\n        - attNamedb: \"run_number\"\n          function: \n            name: \"min\"\n          attNameResource: \"start_run\"\n        - attNamedb: \"stop_time\"\n          function: \n            name: \"max\"\n          attNameResource: \"end_time\"\n          sort:\n            by: \"run_number\"\n            type: \"dense_rank\"\n            order: \"asc\"\n        - attNamedb: \"start_time\"\n          function: \n            name: \"min\"\n          attNameResource: \"start_time\"\n          sort:\n            by: \"run_number\"\n            type: \"dense_rank\"\n            order: \"asc\"\n  defaultSort:\n      fields: [\"name\"]\n      order: \"asc\"\n      nulls: \"last\"\n  pagination: \"disabled\"\n  rowCounting: \"disabled\"\n</code></pre>"},{"location":"Examples/#complex-case-scenarios","title":"Complex Case Scenarios","text":"<p>These examples go beyond direct column mappings. They include derived columns, computed expressions, and the use of functions to transform or aggregate data.</p>"},{"location":"Examples/#expressions-functions-and-nested-ones","title":"Expressions, functions and nested ones","text":"<p>The exmaple resembles the FILL resource, which is the fill of protons happening in the LHC for collisions.  There some attributes with direct mapping to database columns and some, such as the <code>duration_total</code> that is a derived column, a subtract expression betwwen two columns from the master table <code>FILLS</code>.</p> <p>Resource YAML</p> <p>ResourceToDbMapper YAML</p> <pre><code>masterTable: &amp;masterTable \"fills\"\n\nresourceToDbMapper:\n  resource_name: \"fill\"\n  masterTable: \"fills\"\n  dbSchema: \"cms_oms\"\n  primaryKey: \"fill_number\"\n  fields: \n    - attNamedb: \"fill_number\"\n      attNameResource: \"fill_number\"\n    - attNameResource: \"duration_total\"\n      expression:\n        operator: \"subtract\"\n        left: {table: \"fills\", column: \"stop_time\"}\n        right: {table: \"fills\", column: \"start_time\"}\n    - attNameResource: \"efficiency_lumi\"\n      expression: \n        operator: \"divide\"\n        left:\n            operator: \"multiply\"\n            left: 100\n            right: {table: \"fills\", column: \"recorded_lumi\"}\n        right: {table: \"fills\", column: \"delivered_lumi\"}\n  additionalTables:\n    - namedb: \"downtimes\"\n      dbSchema: \"cms_oms\"\n      relation: \"asSubselect\"\n      relationTable: *masterTable\n      relationKeys:\n        - tableKey: \"start_fill_number\" \n          targetKey: \"fill_number\"\n      conditions:\n        - column: \"stable_beams\"  \n          operator: \"eq\"\n          value: 1                   \n        - column: \"enabled\" \n          operator: \"eq\"\n          value: 1      \n      fields: \n        - attNameResource: \"downtime\" \n          function: \n            name: \"sum\" \n            params:\n              - function: \n                  name: \"round\"\n                  params:\n                    - operator: \"multiply\"\n                      left: \n                        operator: \"subtract\"\n                        left: {table: \"downtimes\", column: \"stop_time\"}\n                        right: {table: \"downtimes\", column: \"start_time\"}    \n                      right: 150 \n    - namedb: \"fill_stable_beams\"\n      dbSchema: \"cms_oms\"\n      relation: \"leftJoin\"\n      relationTable: *masterTable\n      relationKeys:\n        - tableKey: \"fill_number\"\n      conditions:\n        - column: \"stable_beams_event\"   # Different names\n          operator: \"eq\"\n          value: 1                         # string, bool, number\n      fields: \n        - attNamedb: \"start_time\"\n          attNameResource: \"start_stable_beam\"\n        - attNamedb: \"end_time\"\n          attNameResource: \"end_stable_beam\"\n        - attNameResource: \"duration\"\n          expression:\n            operator: \"subtract\"\n            left: {table: \"fill_stable_beams\", column: \"end_time\"}\n            right: {table: \"fill_stable_beams\", column: \"start_time\"}\n        - attNamedb: \"to_ready_time\"\n          attNameResource: \"to_ready_time\"\n        - attNamedb: \"to_tracker_ready\"\n          attNameResource: \"to_tracker_ready_time\"\n        - attNamedb: \"dump_ready_to_dump_time\"\n          attNameResource: \"dump_ready_to_dump_time\"\n        - attNamedb: \"to_dump_ready_time\"\n          attNameResource: \"to_dump_ready_time\"\n        - attNameResource: \"stable_beams\"\n          case_expression: \n            - when: { column: \"start_time\", operator: \"isnot\", value: \"null\"}\n              then: 1\n    - namedb: \"runs\"\n      dbSchema: \"cms_oms\"\n      relation: \"asSubselect\"\n      relationTable: *masterTable\n      relationKeys:\n        - tableKey: \"fill_number\"\n      fields: \n        - attNamedb: \"b_field\"\n          attNameResource: \"b_field\"\n          function: \n            name: \"avg\"\n    - namedb: \"scaling_info\"\n      dbSchema: \"cms_oms\"\n      relation: \"leftJoin\"\n      relationTable: *masterTable\n      relationKeys:\n        - tableKey: \"scale_id\"\n      fields:\n        - attNameResource: \"delivered_lumi_stablebeams\"\n          expression: \n            operator: \"multiply\" \n            left: \n              function: \n                name: \"CMS_OMS_AGG.data_summary.get_fill_delivered_lumi\"\n                params: [{table: \"fills\", column: \"fill_number\"}] # optional\n            right: {table: \"scaling_info\", column: \"integrated_lumi_scale_factor\"}\n  defaultSort:\n      fields: [\"fill_number\"]\n      order: \"desc\"\n      nulls: \"last\"\n  pagination: \"enabled\"\n  rowCounting: \"disabled\"\n</code></pre>"},{"location":"Examples/#grouping","title":"Grouping","text":""},{"location":"Expression/","title":"Expression","text":""},{"location":"Expression/#expression","title":"Expression","text":"<p>Represents an arithmetic expression.</p> <p>An <code>Expression</code> is a binary operation composed of:</p> <ul> <li>an <code>ArithmeticOperator</code></li> <li>a <code>left</code> operand</li> <li>a <code>right</code> operand</li> </ul> <p>Both operands may be literals, column references, nested function calls, or even nested expressions.</p> <p>Example YAML</p> <pre><code>expression:\n    operator: \"subtract\"\n    left: {table: \"fills\", column: \"stop_time\"}\n    right: {table: \"fills\", column: \"start_time\"}\n</code></pre> <p>corresponds to: <pre><code>(fills.stop_time - fills.start_time)\n</code></pre></p> <p>Attributes:</p> Name Type Status Description Examples <code>operator</code> ArithmeticOperator Required The arithmetic operator <code>left</code> int, float, DBColumnReference, FunctionCall, Expression Required The left-hand side of the expression <code>right</code> int, float, DBColumnReference, FunctionCall, Expression Required The right-hand side of the expression"},{"location":"Function/","title":"Function","text":""},{"location":"Function/#function","title":"Function","text":"<p>Represents a database function or built-in SQL function call. A <code>Function</code> defines the fully qualified name of the function, along with any optional parameters and whether the call should apply <code>DISTINCT</code>.</p> <p>Example YAML</p> <p><pre><code>function: \n    name: \"count\"\n    distinct: true\n</code></pre> corresponds to: <pre><code>COUNT(DISTINCT column_name)\n</code></pre></p> <p>Attributes:</p> Name Type Status Description Examples <code>name</code> str Required Fully qualified name of the db function to call or any other built-in sql function min, max, count, avg, sum, round, upper, trim <code>params</code> List[ForwardRef('Expression'), ForwardRef('FunctionCall'), DBColumnReference, str, int, float, bool] Optional Optional parameters to pass to the function <code>distinct</code> bool Optional Distinct inside the function"},{"location":"FunctionCall/","title":"FunctionCall","text":""},{"location":"FunctionCall/#functioncall","title":"FunctionCall","text":"<p>Represents an invocation of a <code>Function</code>. A <code>FunctionCall</code> wraps a <code>Function</code> object to be used inside expressions.</p> <p>Attributes:</p> Name Type Status Description Examples <code>function</code> Function Required"},{"location":"MetaData/","title":"MetaData","text":""},{"location":"MetaData/#metadata","title":"MetaData","text":"<p>The MetaData provides descriptive and behavioral information for a resource attribute. It can provide a human-readable title and description, indicate whether the attribute supports filtering and sorting in queries, and specify any associated measurement units.</p> <p>Together, these metadata properties enhance both API usability and query capabilities without altering the structural definition of the attribute itself.</p> <p>Attributes:</p> Name Type Status Description Examples <code>title</code> str Optional <code>description</code> str Optional <code>searchable</code> bool Required Indicates whether this attribute can be used in query filters <code>sortable</code> bool Required Indicates whether this attribute can be used to order query results <code>units</code> Annotated Optional Unit of the attribute, as defined in the supported_units YAML file"},{"location":"Regex/","title":"Regex","text":""},{"location":"Regex/#regex","title":"Regex","text":"<p>Represents a regular expression transformation applied to a column. A <code>Regex</code> extracts or validates parts of a string column using SQL regex functions such as <code>REGEXP_SUBSTR</code>.</p> <p>Attributes:</p> Name Type Status Description Examples <code>column</code> str Required The name of the column to which the regular expression will be applied. It must match one of the defined relation keys <code>pattern</code> str Required The regular expression pattern <code>groups</code> List[int] Required The grouping where the pattern will be applied"},{"location":"RelationKey/","title":"RelationKey","text":""},{"location":"RelationKey/#relationkey","title":"RelationKey","text":"<p>Represents the key mapping between two related tables.  A <code>RelationKey</code> defines how the join between two tables is performed, by specifying which column(s) act as the keys.   Optionally, a regex transformation can be applied to one of the keys.</p> <p>If both tables share the same key name, only <code>tableKey</code> is required.  If the key names differ, then <code>targetKey</code> must also be provided to reference the column name in the related table.</p> <p>Attributes:</p> Name Type Status Description Examples <code>tableKey</code> str Required The name of the database column used to establish the relationship between the two tables. If the column names differ, the <code>targetKey</code> segment must be specified <code>targetKey</code> str Optional The name of the database column of the related table. This segment is used when the column names differ <code>regex</code> Regex Optional A regular expression is applied to one of the relation keys"},{"location":"Resource/","title":"Resource","text":""},{"location":"Resource/#resource","title":"Resource","text":"<p>The Resource model defines the representation of a domain entity exposed through the API.</p> <ul> <li>Each resource has a unique <code>resource_name</code> and may include a <code>version</code> for documentation and lifecycle tracking.</li> <li>A resource is composed of a list of <code>Attribute</code> elements. Each attribute carries:<ul> <li>Structural metadata (e.g. its name, description, units).</li> <li>Behavioral flags that determine how it can be used in the API and in internal query logic (e.g. filtering, sorting, or key fields).</li> </ul> </li> </ul> <p>Together, these properties ensure that a Resource can be consistently documented, validated, and mapped to underlying database entities.</p> <p>Attributes:</p> Name Type Status Description Examples <code>resource_name</code> str Required The name of the resource. All classes will be named using this name era, fill, resource_1, data2024 <code>version</code> str Required Release of a project, marked by a version number 1.0.0 <code>hasMeta</code> bool Optional <code>fields</code> List[Attribute] Required List of the attributes of the resource"},{"location":"Resource/#validators","title":"Validators","text":"<p><code>validate_resource_model:</code> Perform post-validation checks on a Resource definition. This validator runs after field-level validation and case normalization. It ensures that every Resource has a proper identifier field defined.</p> <p>Specifically, it enforces:</p> <ol> <li>Key field requirement<ul> <li>At least one attribute in <code>resource.fields</code> must have <code>isKey=True</code>.</li> <li>This key field serves as the unique identifier of the Resource.</li> <li>Composite identifiers are also supported by marking multiple attributes with <code>isKey=True</code>.</li> </ul> </li> </ol> <p>If no key field is found, a ValueError is raised, clearly listing the issue.</p> <p>This safeguard guarantees that every Resource defined in the specification can be uniquely identified, which is a prerequisite for consistent mapping to database entities and for stable API resource behavior.</p>"},{"location":"ResourceMain/","title":"Definition of Resources","text":""},{"location":"ResourceMain/#resource","title":"Resource","text":"<p>The Resource model defines the representation of a domain entity exposed through the API.</p> <ul> <li>Each resource has a unique <code>resource_name</code> and may include a <code>version</code> for documentation and lifecycle tracking.</li> <li>A resource is composed of a list of <code>Attribute</code> elements. Each attribute carries:<ul> <li>Structural metadata (e.g. its name, description, units).</li> <li>Behavioral flags that determine how it can be used in the API and in internal query logic (e.g. filtering, sorting, or key fields).</li> </ul> </li> </ul> <p>Together, these properties ensure that a Resource can be consistently documented, validated, and mapped to underlying database entities.</p> <p>Attributes:</p> Name Type Status Description Examples <code>resource_name</code> str Required The name of the resource. All classes will be named using this name era, fill, resource_1, data2024 <code>version</code> str Required Release of a project, marked by a version number 1.0.0 <code>hasMeta</code> bool Optional <code>fields</code> List[Attribute] Required List of the attributes of the resource"},{"location":"ResourceMain/#validators","title":"Validators","text":"<p><code>validate_resource_model:</code> Perform post-validation checks on a Resource definition. This validator runs after field-level validation and case normalization. It ensures that every Resource has a proper identifier field defined.</p> <p>Specifically, it enforces:</p> <ol> <li>Key field requirement<ul> <li>At least one attribute in <code>resource.fields</code> must have <code>isKey=True</code>.</li> <li>This key field serves as the unique identifier of the Resource.</li> <li>Composite identifiers are also supported by marking multiple attributes with <code>isKey=True</code>.</li> </ul> </li> </ol> <p>If no key field is found, a ValueError is raised, clearly listing the issue.</p> <p>This safeguard guarantees that every Resource defined in the specification can be uniquely identified, which is a prerequisite for consistent mapping to database entities and for stable API resource behavior.</p>"},{"location":"ResourceMain/#attribute","title":"Attribute","text":"<p>The Attribute defines a single field of a Resource. Each attribute has a name and type, may be marked as the key identifier of the resource, and can optionally include additional metadata for documentation and query behavior.</p> <p>Attributes:</p> Name Type Status Description Examples <code>name</code> str Required Name of the attribute of the resource id, start_time, run_number <code>type</code> str Required The data type of the attribute of the resource according to the standardized mapping_types YAML file <code>isKey</code> bool Optional Explicitly determine true if the attribute is the actual identifier of the resource <code>meta</code> MetaData Optional The meta data of the attribute"},{"location":"ResourceMain/#metadata","title":"MetaData","text":"<p>The MetaData provides descriptive and behavioral information for a resource attribute. It can provide a human-readable title and description, indicate whether the attribute supports filtering and sorting in queries, and specify any associated measurement units.</p> <p>Together, these metadata properties enhance both API usability and query capabilities without altering the structural definition of the attribute itself.</p> <p>Attributes:</p> Name Type Status Description Examples <code>title</code> str Optional <code>description</code> str Optional <code>searchable</code> bool Required Indicates whether this attribute can be used in query filters <code>sortable</code> bool Required Indicates whether this attribute can be used to order query results <code>units</code> Annotated Optional Unit of the attribute, as defined in the supported_units YAML file"},{"location":"ResourceMappingSpec/","title":"ResourceMappingSpec","text":""},{"location":"ResourceMappingSpec/#resourcemappingspec","title":"ResourceMappingSpec","text":"<p>Attributes:</p> Name Type Status Description Examples <code>resource</code> Resource Required The resource object containing metadata and fields."},{"location":"ResourceToDbMain/","title":"Definition of mapping Resources to Database","text":""},{"location":"ResourceToDbMain/#resourcetodbmain","title":"ResourceToDbMain","text":"<p>The ResourceToDbMapper defines how a Resource is linked to physical database elements and how query behavior should be executed.</p> <p>Mapping &amp; validation</p> <ul> <li>Ensures that all resource attributes are mapped to valid database fields or derived expressions.  </li> <li>Verifies that join relationships are correctly defined.  </li> </ul> <p>Database structure</p> <ul> <li>Specifies the primary table via <code>masterTable</code>.  </li> <li>Supports optional <code>additionalTables</code> for joined queries.  </li> </ul> <p>Query behavior</p> <ul> <li>Configures filtering conditions, grouping, sorting, and pagination.  </li> <li>Supports data transformations, including aggregation functions, logical or numerical expressions, and regular expressions.  </li> </ul> <p>By enforcing these rules, the ResourceToDbMapper guarantees that the resource-to-database model is both valid and executable within the API.</p> <p>Attributes:</p> Name Type Status Description Examples <code>resource_name</code> str Optional The name of the resource. Needs to be associated with an existing resource era, fill <code>masterTable</code> str Optional The name of the database's master table <code>dbSchema</code> str Optional The schema of the database's master table <code>primaryKey</code> str Optional The primary key the database's master table <code>fields</code> List[TableAttribute] Required List of the mapping between the attributes of the resource and the fields in the database <code>additionalTables</code> List[AdditionalTable] Required Provides all the information about relations between the master table and other tables <code>groupBy</code> List[str] Optional Applies grouping to the db resultset <code>defaultSort</code> SortedQuery Required Specifies the default sorting to the db resultset <code>pagination</code> Literal[enabled, disabled] Required Paginate the db resultset <code>rowCounting</code> Literal[enabled, disabled] Required Counting of the rows from the db resultset"},{"location":"ResourceToDbMain/#validators","title":"Validators","text":"<p><code>validate_resource_model:</code> Perform cross-object validation between a Resource and its ResourceToDbMapper.</p> <p>This validator runs after individual field validation and case normalization. It enforces consistency between the resource specification (from YAML) and the database mapping definition. Specifically, it checks:</p> <ol> <li>Resource name consistency:</li> <li> <p><code>resourceToDbMapper.resource_name</code> must equal <code>resource.resource_name</code>.</p> </li> <li> <p>Mapping completeness:</p> </li> <li>At least one of <code>resourceToDbMapper.fields</code> or      <code>resourceToDbMapper.additionalTables.fields</code> must be non-empty.</li> <li> <p>Every <code>resource.fields</code> attribute must be mapped to some DB attribute      (direct field, expression, function, or case expression).</p> </li> <li> <p>Attribute name correctness:</p> </li> <li>Every <code>attNameResource</code> in the mapper must correspond to an attribute      defined in the Resource specification.</li> <li> <p>Each mapped field must define at least one of:      <code>attNamedb</code>, <code>function</code>, <code>expression</code>, or <code>case_expression</code>.</p> </li> <li> <p>GroupBy validation:</p> </li> <li> <p>If a <code>groupBy</code> clause is provided, every DB attribute (<code>attNamedb</code>)      without an aggregation function must appear in the <code>groupBy</code> list.</p> </li> <li> <p>DefaultSort validation:</p> </li> <li>If a <code>defaultSort</code> is defined, each item must correspond to a valid      <code>attNameResource</code>.</li> </ol> <p>Errors are aggregated and raised as a single ValueError, making it easier to spot multiple misconfigurations in one pass.</p>"},{"location":"ResourceToDbMain/#tableattribute","title":"TableAttribute","text":"<p>Maps a resource attribute to its corresponding database attribute  or derived expression.</p> <p>A <code>TableAttribute</code> can represent:</p> <ul> <li>a direct database column mapping,</li> <li>an aggregation or built-in SQL function,</li> <li>a custom arithmetic expression,</li> <li>or a CASE expression with conditional branches.</li> </ul> <p>Examples YAML</p> <p><pre><code>- attNamedb: \"fill_number\"\n  attNameResource: \"fill_number\"\n</code></pre> corresponds to: <pre><code>SELECT fill_number as fill_number\n</code></pre></p> <p>Attributes:</p> Name Type Status Description Examples <code>attNamedb</code> str Optional The name of the database column (attribute of the table) <code>attNameResource</code> str Required The name of the attribute as it appears in the resource model <code>function</code> Function Optional Resource attribute is computed using an aggregation, built-in, or custom function <code>expression</code> Expression Optional Resource attribute is an expression-combination of  db attributes, functions, views or values <code>case_expression</code> List[CaseExpression] Optional Resource attribute is a case expression. List of CASE branches: each with a <code>when</code> or <code>else</code> and a <code>then</code> clause <code>sort</code> SortingSubSelect Required Sorting the subselect"},{"location":"ResourceToDbMain/#additionaltable","title":"AdditionalTable","text":"<p>Represents an additional table that can be joined with the master table or another additional table in order to enrich the resource definition.</p> <p>Joins can be defined as <code>innerJoin</code>, <code>leftJoin</code>, <code>rightJoin</code>, or as a <code>subselect</code>.</p> <p>Example YAML</p> <pre><code>additionalTables:\n  - namedb: \"eras\"\n    dbSchema: \"cms_oms\"\n    relation: \"leftJoin\"\n    relationTable: *masterTable\n    relationKeys:\n      - tableKey: \"era_id\"          # Same name in both tables\n        # - tablekey: \"status\"      # Different names\n        #   targetKey: \"era_status\"\n    fields: \n      - attNamedb: \"name\"\n        attNameResource: \"era\"\"\n</code></pre> <p>corresponds to: <pre><code>SELECT eras.name as era\nFROM cms_oms.fills fills\nLEFT JOIN cms_oms.eras eras\n  ON fills.era_id = eras.era_id\n</code></pre></p> <p>Attributes:</p> Name Type Status Description Examples <code>namedb</code> str Required The name of the database's additional table <code>dbSchema</code> str Required The schema of the database's addtional table <code>relation</code> Literal[innerJoin, leftJoin, asSubselect, rightJoin] Required The relation between the master table and the additional table. Options:- <code>innerJoin</code>: Only include matching records from both tables- <code>leftJoin</code>: Include all records from master, and matched from related- <code>rightJoin</code>: Include all records from related, and matched from master- <code>asSubselect</code>: Join via a subquery instead of directly <code>relationTable</code> str Required The name of the table to which the additional table is related. This must match either a previously defined <code>namedb</code> in <code>additionalTables</code> or the <code>masterTable</code> <code>relationKeys</code> List[RelationKey] Required The names of the relation keys (columns) of the tables related <code>conditions</code> List[Condition, Regex] Optional A list of conditions to apply as filters <code>fields</code> List[TableAttribute] Optional List of the mapping between the attributes of the resource and the fields in the database"},{"location":"ResourceToDbMain/#relationkey","title":"RelationKey","text":"<p>Represents the key mapping between two related tables.  A <code>RelationKey</code> defines how the join between two tables is performed, by specifying which column(s) act as the keys.   Optionally, a regex transformation can be applied to one of the keys.</p> <p>If both tables share the same key name, only <code>tableKey</code> is required.  If the key names differ, then <code>targetKey</code> must also be provided to reference the column name in the related table.</p> <p>Attributes:</p> Name Type Status Description Examples <code>tableKey</code> str Required The name of the database column used to establish the relationship between the two tables. If the column names differ, the <code>targetKey</code> segment must be specified <code>targetKey</code> str Optional The name of the database column of the related table. This segment is used when the column names differ <code>regex</code> Regex Optional A regular expression is applied to one of the relation keys"},{"location":"ResourceToDbMain/#condition","title":"Condition","text":"<p>Represents a WHERE condition applied in a query. A <code>Condition</code> defines a table, column, operator, and comparison value. Operators may be arithmetic or comparison operators. Multiple conditions can also be combined in a list.</p> <p>Example YAML</p> <pre><code>conditions:\n  - column: \"stable_beams\"  \n    operator: \"eq\"\n    value: 1                   \n  - column: \"enabled\" \n    operator: \"eq\"\n    value: 1      \n</code></pre> <p>Attributes:</p> Name Type Status Description Examples <code>table</code> str Optional The table name of the referenced column <code>column</code> str Required The name of the database column that the condition applies to run_number, name, status <code>operator</code> ArithmeticOperator, ComparisonOperator Required The comparison or arithmetic operator to use in the condition eq <code>value</code> str, int, float, bool, List[str, int, float, bool] Required The value to compare the column against. It can be a string, number, boolean, or a list of such values (used with the <code>in</code> operator). string_value, 42, True, [1, 2, 3]"},{"location":"ResourceToDbMain/#function","title":"Function","text":"<p>Represents a database function or built-in SQL function call. A <code>Function</code> defines the fully qualified name of the function, along with any optional parameters and whether the call should apply <code>DISTINCT</code>.</p> <p>Example YAML</p> <p><pre><code>function: \n    name: \"count\"\n    distinct: true\n</code></pre> corresponds to: <pre><code>COUNT(DISTINCT column_name)\n</code></pre></p> <p>Attributes:</p> Name Type Status Description Examples <code>name</code> str Required Fully qualified name of the db function to call or any other built-in sql function min, max, count, avg, sum, round, upper, trim <code>params</code> List[ForwardRef('Expression'), ForwardRef('FunctionCall'), DBColumnReference, str, int, float, bool] Optional Optional parameters to pass to the function <code>distinct</code> bool Optional Distinct inside the function"},{"location":"ResourceToDbMain/#expression","title":"Expression","text":"<p>Represents an arithmetic expression.</p> <p>An <code>Expression</code> is a binary operation composed of:</p> <ul> <li>an <code>ArithmeticOperator</code></li> <li>a <code>left</code> operand</li> <li>a <code>right</code> operand</li> </ul> <p>Both operands may be literals, column references, nested function calls, or even nested expressions.</p> <p>Example YAML</p> <pre><code>expression:\n    operator: \"subtract\"\n    left: {table: \"fills\", column: \"stop_time\"}\n    right: {table: \"fills\", column: \"start_time\"}\n</code></pre> <p>corresponds to: <pre><code>(fills.stop_time - fills.start_time)\n</code></pre></p> <p>Attributes:</p> Name Type Status Description Examples <code>operator</code> ArithmeticOperator Required The arithmetic operator <code>left</code> int, float, DBColumnReference, FunctionCall, Expression Required The left-hand side of the expression <code>right</code> int, float, DBColumnReference, FunctionCall, Expression Required The right-hand side of the expression"},{"location":"ResourceToDbMain/#caseexpression","title":"CaseExpression","text":"<p>Represents a CASE expression in SQL. A <code>CaseExpression</code> evaluates a condition and returns a value via the <code>then</code> clause. If no <code>when</code> branch matches, the optional <code>else</code> provides a fallback value.</p> <p>Example YAML</p> <pre><code>case_expression: \n  - when: { column: \"start_time\", operator: \"isnot\", value: \"null\"}\n    then: 1\n</code></pre> <p>corresponds to: <pre><code>CASE\n  WHEN start_time IS NOT NULL THEN 1\nEND\n</code></pre></p> <p>Attributes:</p> Name Type Status Description Examples <code>when</code> Condition Required A condition that must be met for this branch to apply. Must contain <code>column</code>, <code>operator</code>, and/or <code>value</code> {'column': 'stablebeam', 'operator': 'eq', 'value': 1} <code>else_</code> str Required Fallback value if no conditions match <code>then</code> str Required The resulting value if this condition matches"},{"location":"ResourceToDbMain/#regex","title":"Regex","text":"<p>Represents a regular expression transformation applied to a column. A <code>Regex</code> extracts or validates parts of a string column using SQL regex functions such as <code>REGEXP_SUBSTR</code>.</p> <p>Attributes:</p> Name Type Status Description Examples <code>column</code> str Required The name of the column to which the regular expression will be applied. It must match one of the defined relation keys <code>pattern</code> str Required The regular expression pattern <code>groups</code> List[int] Required The grouping where the pattern will be applied"},{"location":"ResourceToDbMain/#dbcolumnreference","title":"DBColumnReference","text":"<p>References a database column by its table and column name. Used throughout the specification to unambiguously refer to database fields in conditions, expressions, or mappings.</p> <p>Example YAML</p> <pre><code>table: \"eras\"\ncolumn: \"name\"\n</code></pre> <p>corresponds to: <pre><code>eras.name\n</code></pre></p> <p>Attributes:</p> Name Type Status Description Examples <code>table</code> str Required The table name of the referenced column <code>column</code> str Required The name of the column being referenced."},{"location":"ResourceToDbMain/#sortedquery","title":"SortedQuery","text":"<p>Represents an ORDER BY clause in a query. A <code>SortedQuery</code> defines which attributes can be sorted, the sorting direction, and whether null values appear first or last. This defines the default sorting of the resource if no sorting is specified in the REST request.</p> <p>Example YAML</p> <pre><code>defaultSort:\n  fields: [\"name\"]\n  order: \"asc\"\n  nulls: \"last\"\n</code></pre> <p>corresponds to: <pre><code>ORDER BY name ASC NULLS LAST\n</code></pre></p> <p>Attributes:</p> Name Type Status Description Examples <code>fields</code> List[str] Required List of the accepted attributes to be sorted <code>order</code> Literal[asc, desc] Optional Accepted order for the sorted query <code>nulls</code> Literal[last, first] Optional Show nulls last or first"},{"location":"ResourceToDbMain/#sortingsubselect","title":"SortingSubSelect","text":"<p>Represents a window function ordering applied in a subselect. A <code>SortingSubSelect</code> specifies the field, ordering method, and direction used when sorting rows with ranking functions like <code>RANK</code> or <code>ROW_NUMBER</code>.</p> <p>Example YAML</p> <p><pre><code>sort:\n  by: \"run_number\"\n  type: \"dense_rank\"\n  order: \"desc\"\n</code></pre> corresponds to: <pre><code>DENSE_RANK() OVER (ORDER BY run_number DESC)\n</code></pre></p> <p>Attributes:</p> Name Type Status Description Examples <code>by</code> str Required The field name to sort by, e.g., 'run_number'. <code>type</code> Literal[dense_rank, rank, row_number] Required The sort method to use. Options include:- 'dense_rank': Assigns ranks with no gaps in ranking values.- 'rank': Like dense_rank but leaves gaps in the ranking sequence for ties.- 'row_number': Assigns a unique sequential number to rows. <code>order</code> Literal[asc, desc] Required The direction of sorting: 'asc' for ascending, 'desc' for descending."},{"location":"ResourceToDbMain/#constant-variables","title":"Constant Variables","text":""},{"location":"ResourceToDbMain/#arithmeticoperator","title":"ArithmeticOperator","text":"<p><code>StrEnum</code>  representing the basic arithmetic operators. Each enum value has both a short name (used in YAML / DSL) and a corresponding symbolic representation (via the <code>symbol</code> property).</p> Name Symbol Description <code>multiply</code> <code>*</code> Represents multiply <code>divide</code> <code>/</code> Represents divide <code>subtract</code> <code>-</code> Represents subtract <code>add</code> <code>+</code> Represents add <p>The name of the operator follows strict naming conventions. Referencing a non-existent name will raise an error. Check Error messages</p> Constant variables <p>Enums are contstant variables, the names of the enums follows strict naming conventions. Referencing a non-existent name will raise an error. Error messages</p> add_number.py<pre><code># Function to add two numbers\ndef add_two_numbers(num1, num2):\n    return num1 + num2\n\n# Example usage\nresult = add_two_numbers(5, 3)\nprint('The sum is:', result)\n</code></pre>"},{"location":"ResourceToDbMain/#comparisonoperator","title":"ComparisonOperator","text":"<p><code>StrEnum</code> representing the supported comparison operators used in filtering conditions (e.g. when building queries). Each enum value has both a short name (used in YAML / DSL) and a corresponding symbolic representation (via the <code>symbol</code> property).</p> Name Symbol Description <code>\"eq\"</code> <code>=</code> Equality check <code>\"ne\"</code> <code>!=</code> Inequality check <code>\"lt\"</code> <code>&lt;</code> Strictly less than <code>\"lte\"</code> <code>&lt;=</code> Less than or equal <code>\"gt\"</code> <code>&gt;</code> Strictly greater than <code>\"gte\"</code> <code>&gt;=</code> Greater than or equal <code>\"like\"</code> <code>like</code> Pattern matching (SQL <code>LIKE</code>) <code>\"in\"</code> <code>in</code> Membership in a collection <code>\"is\"</code> <code>is</code> Identity / null check <code>\"isnot\"</code> <code>is not</code> Negated identity / null check <pre><code># Example usage\nop = ComparisonOperator.EQUAL\nprint(op.value)   # \"eq\"\nprint(op.symbol)  # \"=\"\n</code></pre>"},{"location":"ResourceToDbMapper/","title":"ResourceToDbMapper","text":""},{"location":"ResourceToDbMapper/#resourcetodbmapper","title":"ResourceToDbMapper","text":"<p>Attributes:</p> Name Type Status Description Examples <code>resource_name</code> str Required The name of the resource. Needs to be associated with an existing resource era, fill <code>masterTable</code> str Required The name of the database's master table <code>dbSchema</code> str Required The schema of the database's master table <code>primaryKey</code> str Optional The primary key the database's master table <code>fields</code> List[TableAttribute] Optional List of the mapping between the attributes of the resource and the fields in the database <code>additionalTables</code> List[AdditionalTable] Optional Provides all the information about relations between the master table and other tables <code>groupBy</code> List[str] Optional Applies grouping to the db resultset <code>defaultSort</code> SortedQuery Optional Specifies the default sorting to the db resultset <code>pagination</code> Literal[enabled, disabled] Required Paginate the db resultset <code>rowCounting</code> Literal[enabled, disabled] Required Counting of the rows from the db resultset"},{"location":"ResourceToDbMappingSpec/","title":"ResourceToDbMappingSpec","text":""},{"location":"ResourceToDbMappingSpec/#resourcetodbmappingspec","title":"ResourceToDbMappingSpec","text":"<p>The ResourceToDbMapper defines how a Resource is linked to physical database elements and how query behavior should be executed.</p> <p>Mapping &amp; validation     - Ensures that all resource attributes are mapped to valid database fields or derived expressions.     - Verifies that join relationships are correctly defined.  </p> <p>Database structure     - Specifies the primary table via <code>masterTable</code>.     - Supports optional <code>additionalTables</code> for joined queries.  </p> <p>Query behavior     - Configures filtering conditions, grouping, sorting, and pagination.     - Supports data transformations, including aggregation functions, logical or numerical expressions, and regular expressions.  </p> <p>By enforcing these rules, the ResourceToDbMapper guarantees that the resource-to-database model is both valid and executable within the API.</p> <p>Attributes:</p> Name Type Status Description Examples <code>masterTable</code> str Optional <code>resourceToDbMapper</code> ResourceToDbMapper Required Mapping of a resource to its database schema <code>resource</code> Resource Required The specification of the resource."},{"location":"ResourceToDbMappingSpec/#validators","title":"Validators","text":"<p><code>validate_resource_model:</code> Perform cross-object validation between a Resource and its ResourceToDbMapper.</p> <p>This validator runs after individual field validation and case normalization. It enforces consistency between the resource specification (from YAML) and the database mapping definition. Specifically, it checks:</p> <ol> <li>Resource name consistency:</li> <li> <p><code>resourceToDbMapper.resource_name</code> must equal <code>resource.resource_name</code>.</p> </li> <li> <p>Mapping completeness:</p> </li> <li>At least one of <code>resourceToDbMapper.fields</code> or      <code>resourceToDbMapper.additionalTables.fields</code> must be non-empty.</li> <li> <p>Every <code>resource.fields</code> attribute must be mapped to some DB attribute      (direct field, expression, function, or case expression).</p> </li> <li> <p>Attribute name correctness:</p> </li> <li>Every <code>attNameResource</code> in the mapper must correspond to an attribute      defined in the Resource specification.</li> <li> <p>Each mapped field must define at least one of:      <code>attNamedb</code>, <code>function</code>, <code>expression</code>, or <code>case_expression</code>.</p> </li> <li> <p>GroupBy validation:</p> </li> <li> <p>If a <code>groupBy</code> clause is provided, every DB attribute (<code>attNamedb</code>)      without an aggregation function must appear in the <code>groupBy</code> list.</p> </li> <li> <p>DefaultSort validation:</p> </li> <li>If a <code>defaultSort</code> is defined, each item must correspond to a valid      <code>attNameResource</code>.</li> </ol> <p>Errors are aggregated and raised as a single ValueError, making it easier to spot multiple misconfigurations in one pass.</p>"},{"location":"SortedQuery/","title":"SortedQuery","text":""},{"location":"SortedQuery/#sortedquery","title":"SortedQuery","text":"<p>Represents an ORDER BY clause in a query. A <code>SortedQuery</code> defines which attributes can be sorted, the sorting direction, and whether null values appear first or last. This defines the default sorting of the resource if no sorting is specified in the REST request.</p> <p>Example YAML</p> <pre><code>defaultSort:\n  fields: [\"name\"]\n  order: \"asc\"\n  nulls: \"last\"\n</code></pre> <p>corresponds to: <pre><code>ORDER BY name ASC NULLS LAST\n</code></pre></p> <p>Attributes:</p> Name Type Status Description Examples <code>fields</code> List[str] Required List of the accepted attributes to be sorted <code>order</code> Literal[asc, desc] Optional Accepted order for the sorted query <code>nulls</code> Literal[last, first] Optional Show nulls last or first"},{"location":"SortingSubSelect/","title":"SortingSubSelect","text":""},{"location":"SortingSubSelect/#sortingsubselect","title":"SortingSubSelect","text":"<p>Represents a window function ordering applied in a subselect. A <code>SortingSubSelect</code> specifies the field, ordering method, and direction used when sorting rows with ranking functions like <code>RANK</code> or <code>ROW_NUMBER</code>.</p> <p>Example YAML</p> <p><pre><code>sort:\n  by: \"run_number\"\n  type: \"dense_rank\"\n  order: \"desc\"\n</code></pre> corresponds to: <pre><code>DENSE_RANK() OVER (ORDER BY run_number DESC)\n</code></pre></p> <p>Attributes:</p> Name Type Status Description Examples <code>by</code> str Required The field name to sort by, e.g., 'run_number'. <code>type</code> Literal[dense_rank, rank, row_number] Required The sort method to use. Options include:- 'dense_rank': Assigns ranks with no gaps in ranking values.- 'rank': Like dense_rank but leaves gaps in the ranking sequence for ties.- 'row_number': Assigns a unique sequential number to rows. <code>order</code> Literal[asc, desc] Required The direction of sorting: 'asc' for ascending, 'desc' for descending."},{"location":"TableAttribute/","title":"TableAttribute","text":""},{"location":"TableAttribute/#tableattribute","title":"TableAttribute","text":"<p>Maps a resource attribute to its corresponding database attribute  or derived expression.</p> <p>A <code>TableAttribute</code> can represent:</p> <ul> <li>a direct database column mapping,</li> <li>an aggregation or built-in SQL function,</li> <li>a custom arithmetic expression,</li> <li>or a CASE expression with conditional branches.</li> </ul> <p>Examples YAML</p> <p><pre><code>- attNamedb: \"fill_number\"\n  attNameResource: \"fill_number\"\n</code></pre> corresponds to: <pre><code>SELECT fill_number as fill_number\n</code></pre></p> <p>Attributes:</p> Name Type Status Description Examples <code>attNamedb</code> str Optional The name of the database column (attribute of the table) <code>attNameResource</code> str Required The name of the attribute as it appears in the resource model <code>function</code> Function Optional Resource attribute is computed using an aggregation, built-in, or custom function <code>expression</code> Expression Optional Resource attribute is an expression-combination of  db attributes, functions, views or values <code>case_expression</code> List[CaseExpression] Optional Resource attribute is a case expression. List of CASE branches: each with a <code>when</code> or <code>else</code> and a <code>then</code> clause <code>sort</code> SortingSubSelect Required Sorting the subselect"},{"location":"TypoDetectingModel/","title":"TypoDetectingModel","text":""},{"location":"TypoDetectingModel/#typodetectingmodel","title":"TypoDetectingModel","text":"<p>Attributes:</p> Name Type Status Description Examples"},{"location":"TypoDetectingModel/#validators","title":"Validators","text":"<p><code>validate_resource_model:</code> Pre-processor for input data: corrects case variations and flags likely typos.</p> <p>This validator runs before standard field validation. Its purpose is to normalize input keys and catch common mistakes early, improving both robustness and user experience.</p> <p>Specifically, it: 1. Case correction:    - Accepts field names in any case (e.g., <code>ResourceName</code>, <code>resourcename</code>)      and maps them back to the canonical field defined in the model.</p> <ol> <li>Typo detection:</li> <li>Uses fuzzy matching to detect close matches to known field names.</li> <li> <p>If a likely match is found, raises an error with a suggestion:      e.g., <code>\"Unexpected field 'resouce'. Did you mean 'resource'?\"</code></p> </li> <li> <p>Unknown field rejection:</p> </li> <li>If no close match is found and the field is not in the allowed exceptions      (<code>java_type</code>, <code>db_type</code>), raises an error about the unknown field.</li> </ol> <p>Returns:     A corrected dictionary of field names \u2192 values, ready for standard validation.</p> <p>Raises:     ValueError: If unrecognized or mistyped fields are detected.</p>"},{"location":"enum/","title":"Enum","text":""},{"location":"enum/#constant-variables","title":"Constant Variables","text":""},{"location":"enum/#arithmeticoperator","title":"ArithmeticOperator","text":"<p><code>StrEnum</code>  representing the basic arithmetic operators. Each enum value has both a short name (used in YAML / DSL) and a corresponding symbolic representation (via the <code>symbol</code> property).</p> Name Symbol Description <code>multiply</code> <code>*</code> Represents multiply <code>divide</code> <code>/</code> Represents divide <code>subtract</code> <code>-</code> Represents subtract <code>add</code> <code>+</code> Represents add <p>The name of the operator follows strict naming conventions. Referencing a non-existent name will raise an error. Check Error messages</p> Constant variables <p>Enums are contstant variables, the names of the enums follows strict naming conventions. Referencing a non-existent name will raise an error. Error messages</p> add_number.py<pre><code># Function to add two numbers\ndef add_two_numbers(num1, num2):\n    return num1 + num2\n\n# Example usage\nresult = add_two_numbers(5, 3)\nprint('The sum is:', result)\n</code></pre>"},{"location":"enum/#comparisonoperator","title":"ComparisonOperator","text":"<p><code>StrEnum</code> representing the supported comparison operators used in filtering conditions (e.g. when building queries). Each enum value has both a short name (used in YAML / DSL) and a corresponding symbolic representation (via the <code>symbol</code> property).</p> Name Symbol Description <code>\"eq\"</code> <code>=</code> Equality check <code>\"ne\"</code> <code>!=</code> Inequality check <code>\"lt\"</code> <code>&lt;</code> Strictly less than <code>\"lte\"</code> <code>&lt;=</code> Less than or equal <code>\"gt\"</code> <code>&gt;</code> Strictly greater than <code>\"gte\"</code> <code>&gt;=</code> Greater than or equal <code>\"like\"</code> <code>like</code> Pattern matching (SQL <code>LIKE</code>) <code>\"in\"</code> <code>in</code> Membership in a collection <code>\"is\"</code> <code>is</code> Identity / null check <code>\"isnot\"</code> <code>is not</code> Negated identity / null check <pre><code># Example usage\nop = ComparisonOperator.EQUAL\nprint(op.value)   # \"eq\"\nprint(op.symbol)  # \"=\"\n</code></pre>"},{"location":"errors/","title":"Erros messages","text":""}]}